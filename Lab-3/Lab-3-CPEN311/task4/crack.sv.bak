module crack(input logic clk, input logic rst_n,
            input logic en, output logic rdy,
            output logic [23:0] key, output logic key_valid,
            output logic [7:0] ct_addr, input logic [7:0] ct_rddata);

    wire [7:0] a4_addr_pt, cpt_addr_pt, wr_data, rd_d_pt;
	reg [23:0] key;
	reg [7:0] wr_data;
	reg en_a4, en_cpt, rdy_a4, rdy_cpt, ptwren;
	reg [3:0] state = 0;

	localparam idle = 0;
	localparam wt_rdy_a4 = 1;
	localparam do_a4 = 2;
	localparam wt_rdy_cpt = 3;
	localparam do_cpt = 4;

    // this memory must have the length-prefixed plaintext if key_valid
    pt_mem 	  pt(.address(ptaddr), .clock(clk), .data(wr_data), .wren(ptwren), .q(rd_d_pt));
    arc4      a4( .clk, .rst_n, .en(en_a4),  .rdy(rdy_a4), .pt_addr(a4_addr_pt), .pt_rddata(rd_d_pt), .pt_wrdata(wr_data), .pt_wren(wren), .ct_rddata,  .ct_addr, .key);
	check_pt  cpt(.clk, .rst_n, .en(en_cpt), .rdy(rdy_cpt),   .addr(cpt_addr_pt),  .rd_data(rd_d_pt), .key_valid);

	always_comb begin
		{rdy, en_a4, en_cpt, ptaddr, wr_data} = 0;
		case (state)
			idle:			begin rdy = 1; end
			wt_rdy_a4: 		begin en_a4 = rdy_a4; end
			do_a4:			begin ptaddr = a4_addr_pt; end
			wt_rdy_cpt: 	begin en_cpt = rdy_cpt; end
			do_cpt:			begin ptaddr = cpt_addr_pt; end
		endcase
	end

	always_ff @(posedge clk, negedge rst_n) begin
		idle: 			begin 
							state <= en ? wt_rdy_a4 : idle;				 			
						end
		wt_rdy_a4:		begin
							state <= rdy_a4 ? do_a4 : wt_rdy_a4;
						end
		do_a4:			begin
							state <= rdy_a4 ? wt_rdy_cpt : do_a4;
						end
		wt_rdy_cpt: 	begin
							state <= rdy_cpt ? do_cpt : wt_rdy_cpt;
						end
		do_cpt:			begin
							state <= rdy_cpt ? idle : do_cpt;
						end
		default:			state <= idle;
	end

endmodule: crack

module check_pt(input logic clk, input logic rst_n, input logic en, 
			  input logic [7:0] rd_data, output logic addr,
			  output logic rdy, output logic key_valid);

	reg in_range, is_valid;
	reg [1:0] state;
	reg [7:0] i, len;

	assign in_range = rd_data > 8'h1f && rd_data < 8'h7f;
	assign key_valid = is_valid;

	localparam idle = 0;
	localparam rd_len = 1;
	localparam ld_adr = 2;
	localparam ck_key = 3;

	always_comb begin
		case(state)
			idle: 	begin rdy = 1; addr = 0; end
			rd_len:	begin rdy = 0; addr = 0; end
			ld_adr: begin rdy = 0; addr = i; end
			ck_key: begin rdy = 0; addr = 0; end
		endcase
	end

	always_ff @(posedge clk, negedge rst_n) begin 
		if (!rst_n) begin
			state = idle;
			i = 1;
			is_valid = 0;
		end else begin
			case(state)
				idle:		
					state <= en ? rd_len : idle;
				rd_len:	begin 
					state <= ld_adr;
					len <= rd_data;
					i <= 1;
				end
				ld_adr: 
					state <= ck_key;
				ck_key: begin
					state <= in_range && i < len ? ld_adr : idle;
					is_valid <= in_range;
				end
			endcase
		end
	end

endmodule: check_pt